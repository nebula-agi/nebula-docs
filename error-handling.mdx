---
title: 'Error Handling'
description: 'Comprehensive guide to error handling in Nebula using NebulaException and best practices'
---

# Error Handling

Nebula provides a robust error handling system built around the `NebulaException` class and its specialized variants. This page covers how to handle errors effectively when working with the Nebula API.

## NebulaException Overview

`NebulaException` is the base exception class in Nebula, designed to provide structured error information including status codes, detailed error messages, and additional context. It's used throughout the Nebula ecosystem to ensure consistent error handling.

### Exception Hierarchy

Nebula provides several specialized exception types that inherit from `NebulaException`:

| Exception Type | Status Code | Description |
|----------------|-------------|-------------|
| `NebulaException` | Variable | Base exception for all Nebula errors |
| `NebulaClientException` | N/A | Client-side errors (network, configuration) |
| `NebulaAuthenticationException` | 401 | Authentication failures |
| `NebulaRateLimitException` | 429 | Rate limiting errors |
| `NebulaValidationException` | 400 | Input validation errors |
| `NebulaClusterNotFoundException` | 404 | Missing cluster references |

## Authentication Errors

The most common errors you'll encounter are related to authentication and authorization:

| Status Code | Error Type | Description |
|-------------|------------|-------------|
| 401 | `NebulaAuthenticationException` | Invalid or missing authentication |
| 403 | `Forbidden` | Valid authentication but insufficient permissions |
| 404 | `Not Found` | API key or cluster not found |

### Example Error Response

```json
{
  "error": "NebulaAuthenticationException",
  "message": "Invalid API key provided",
  "statusCode": 401,
  "details": {
    "error_type": "authentication_error",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

## Handling Errors in Code

Nebula's SDKs provide consistent error handling patterns across all supported languages.

<Tabs>
  <Tab title="Python">
    ```python
    from nebula_client import NebulaClient, NebulaException, NebulaAuthenticationException

    client = NebulaClient(api_key="your-api-key")

    try:
        memories = client.list_memories(cluster_ids=["your-cluster-id"])
        print(f"Found {len(memories)} memories")
    except NebulaAuthenticationException as e:
        print(f"Authentication failed: {e.message}")
        # Handle authentication error (e.g., refresh token, prompt user)
    except NebulaRateLimitException as e:
        print(f"Rate limit exceeded. Retry after: {e.details.get('retry_after', 'unknown')}")
        # Implement exponential backoff
    except NebulaValidationException as e:
        print(f"Validation error: {e.message}")
        print(f"Details: {e.details}")
        # Handle validation errors (e.g., fix input data)
    except NebulaException as e:
        print(f"Nebula API error ({e.status_code}): {e.message}")
        # Handle general API errors
    except Exception as e:
        print(f"Unexpected error: {e}")
        # Handle unexpected errors
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const { NebulaSDK, NebulaException, NebulaAuthenticationException } = require('@nebula-ai/sdk');

    const client = new NebulaSDK({
      apiKey: 'your-api-key'
    });

    async function listMemories() {
      try {
        const memories = await client.listMemories({
          clusterId: 'your-cluster-id'
        });
        console.log(`Found ${memories.length} memories`);
      } catch (error) {
        if (error instanceof NebulaAuthenticationException) {
          console.error('Authentication failed:', error.message);
          // Handle authentication error
        } else if (error instanceof NebulaRateLimitException) {
          console.error('Rate limit exceeded:', error.message);
          // Implement retry with backoff
        } else if (error instanceof NebulaValidationException) {
          console.error('Validation error:', error.message);
          console.error('Details:', error.details);
          // Handle validation errors
        } else if (error instanceof NebulaException) {
          console.error(`Nebula API error (${error.statusCode}):`, error.message);
          // Handle general API errors
        } else {
          console.error('Unexpected error:', error);
          // Handle unexpected errors
        }
      }
    }
    ```
  </Tab>
  <Tab title="Go">
    ```go
    import (
        "fmt"
        "strings"
        nebulaclient "github.com/oronila/nebula-client-go/nebulaclient"
    )

    client := nebulaclient.NewClient("your-api-key")

    memories, err := client.ListMemories("your-cluster-id", "ROOT")
    if err != nil {
        if strings.Contains(err.Error(), "401") {
            fmt.Println("Authentication failed. Check your API key.")
        } else if strings.Contains(err.Error(), "403") {
            fmt.Println("Insufficient permissions for this operation.")
        } else if strings.Contains(err.Error(), "429") {
            fmt.Println("Rate limit exceeded. Please wait before retrying.")
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
    ```
  </Tab>
  <Tab title="cURL">
    ```bash
    # Authentication error example
    curl -H "Authorization: ApiKey invalid_key" \
         https://api.nebulacloud.app/clusters/your-cluster-id/files/list

    # Response:
    # {
    #   "error": "NebulaAuthenticationException",
    #   "message": "Invalid API key",
    #   "statusCode": 401
    # }
    ```
  </Tab>
</Tabs>

## Best Practices

### 1. Use Specific Exception Types

Always catch the most specific exception types first, then fall back to more general ones:

```python
try:
    result = client.some_operation()
except NebulaAuthenticationException:
    # Handle auth errors specifically
except NebulaRateLimitException:
    # Handle rate limits
except NebulaException:
    # Handle other API errors
```

### 2. Implement Retry Logic

For transient errors, implement exponential backoff:

```python
import time
import random

def retry_with_backoff(func, max_retries=3, base_delay=1):
    for attempt in range(max_retries):
        try:
            return func()
        except NebulaRateLimitException as e:
            if attempt == max_retries - 1:
                raise
            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)
            time.sleep(delay)
        except NebulaAuthenticationException:
            # Don't retry auth errors
            raise
```

### 3. Log Errors Appropriately

```python
import logging

logger = logging.getLogger(__name__)

try:
    result = client.upload_file(file_path, cluster_id)
except NebulaException as e:
    logger.error(f"Nebula API error: {e.message}", extra={
        'status_code': e.status_code,
        'details': e.details,
        'operation': 'upload_file'
    })
    raise
```

### 4. Handle Network Errors

Network-related errors should be handled separately from API errors:

```python
try:
    result = client.list_memories(cluster_ids=[cluster_id])
except requests.exceptions.ConnectionError:
    logger.error("Network connection failed")
    # Implement retry or fallback logic
except requests.exceptions.Timeout:
    logger.error("Request timed out")
    # Implement retry with longer timeout
except NebulaException as e:
    # Handle API-specific errors
    logger.error(f"Nebula API error: {e.message}")
```

## Common Error Scenarios

### Rate Limiting

```python
try:
    # Operation that might be rate limited
    memories = client.search_memories(query="important data")
except NebulaRateLimitException as e:
    retry_after = e.details.get('retry_after', 60)
    print(f"Rate limited. Retry after {retry_after} seconds")
    time.sleep(retry_after)
    # Retry the operation
```

### Validation Errors

```python
try:
    # Create a memory with invalid data
    memory = client.create_memory({
        "content": "",  # Empty content
        "cluster_id": "invalid-cluster"
    })
except NebulaValidationException as e:
    print(f"Validation failed: {e.message}")
    for field, errors in e.details.items():
        print(f"- {field}: {', '.join(errors)}")
```

### Authentication Token Expiration

```python
class AuthenticatedClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.client = NebulaClient(api_key=api_key)

    def _refresh_token_if_needed(self):
        # Implement token refresh logic here
        pass

    def safe_operation(self, operation, *args, **kwargs):
        try:
            return operation(*args, **kwargs)
        except NebulaAuthenticationException:
            self._refresh_token_if_needed()
            return operation(*args, **kwargs)
```

## Error Recovery Strategies

### Circuit Breaker Pattern

Implement a circuit breaker to prevent cascading failures:

```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, recovery_timeout=60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN

    def call(self, func):
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = 'HALF_OPEN'
            else:
                raise Exception("Circuit breaker is OPEN")

        try:
            result = func()
            self._on_success()
            return result
        except NebulaException as e:
            self._on_failure()
            raise

    def _on_success(self):
        self.failure_count = 0
        self.state = 'CLOSED'

    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        if self.failure_count >= self.failure_threshold:
            self.state = 'OPEN'
```

## Monitoring and Alerting

### Log Aggregation

Set up proper logging to capture error patterns:

```python
import logging
import json

class NebulaErrorHandler:
    def __init__(self):
        self.logger = logging.getLogger('nebula_errors')
        self.logger.setLevel(logging.ERROR)

    def handle_error(self, error: NebulaException, context: dict = None):
        error_data = {
            'error_type': type(error).__name__,
            'message': error.message,
            'status_code': error.status_code,
            'details': error.details,
            'timestamp': time.time(),
            'context': context or {}
        }

        self.logger.error(json.dumps(error_data))
```

## Next Steps

- [Authentication](/authentication) - Learn about API key management
- [API Reference](/api-reference/overview) - Explore all available endpoints
- [Rate Limiting](/guides/rate-limiting) - Understand rate limit policies
