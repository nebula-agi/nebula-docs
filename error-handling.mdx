---
title: 'Error Handling'
description: 'Comprehensive guide to handling Nebula errors with clear retry rules and best practices'
---

# Error Handling

Nebula errors follow standard HTTP semantics and map to typed SDK exceptions so applications can decide when to fail fast and when to retry safely.

## At a glance

- Never retry 401/403 without changing credentials or permissions; treat 429/5xx as transient with jittered backoff and a cap.
- Log the correlation/request ID from error responses for debugging while avoiding sensitive data in logs.

## Common errors

| Status | When it happens | Action |
|---|---|---|
| 400/422 | Invalid inputs or schema violations | Fix request and do not retry until corrected; log validation details safely. |
| 401 | Missing/invalid Authorization header or key | Do not retry without changing credentials; re-authenticate and reissue. |
| 403 | Authenticated but insufficient permissions/scope | Do not retry; adjust key scope/permissions and try again. |
| 404 | Resource or cluster not found | Verify identifiers or scope; do not blind-retry. |
| 409 | Conflict (state/version) | Resolve conflict or use idempotency/versioning before retry. |
| 429 | Rate limited | Retry with capped exponential backoff and jitter; respect server hints if present. |
| 5xx | Transient server error | Retry with capped exponential backoff and jitter; escalate if persistent. |

## Exception hierarchy and HTTP mapping

| Exception | Typical HTTP | Meaning |
|---|---|---|
| `NebulaException` | Varies | Base class with status code, message, details, and `request_id`. |
| `NebulaClientException` | N/A | Client/network/configuration issues before a response. |
| `NebulaAuthenticationException` | 401 | Invalid or missing authentication. |
| `NebulaRateLimitException` | 429 | Rate limit exceeded; transient. |
| `NebulaValidationException` | 400/422 | Invalid parameters or payload. |

## Error payloads

Nebula error responses include a stable shape with non-sensitive context and a correlation ID for support and tracing.

```json
{
  "error": "NebulaRateLimitException",
  "message": "Too Many Requests",
  "statusCode": 429,
  "details": { "hint": "reduce request rate" },
  "request_id": "req_12345"
}
```

## When to retry

- Retry 429 and 5xx with capped exponential backoff and jitter to spread retries and reduce contention.
- Do not retry 400/401/403/404 without changing the request, credentials, or permissions; these are not transient.

## Backoff with jitter

Use capped exponential backoff with full jitter; prefer idempotency for writes.

<CodeGroup>

```javascript retry.js
async function retryWithJitter(fn, { retries = 4, base = 300, factor = 2, cap = 5000 } = {}) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (e) {
      if (i === retries - 1) throw e;
      const exp = Math.min(cap, base * Math.pow(factor, i));
      const delay = Math.random() * exp; // full jitter
      await new Promise(r => setTimeout(r, delay));
    }
  }
}
```

```python retry.py
import random, time

def retry_with_jitter(fn, retries=4, base=0.3, factor=2.0, cap=5.0):
    for i in range(retries):
        try:
            return fn()
        except Exception:
            if i == retries - 1:
                raise
            exp = min(cap, base * (factor ** i))
            time.sleep(random.random() * exp)  # full jitter
```

</CodeGroup>

## Language examples

- Catch specific exceptions first, then fall back to the base type for a single reporting/logging path.
- Include the request context and status code in logs, and avoid logging secrets or full payloads containing sensitive data.

<CodeGroup>

```python error_handling.py
from nebula_client import (
    NebulaClient,
    NebulaException,
    NebulaAuthenticationException,
    NebulaRateLimitException,
    NebulaValidationException,
)

client = NebulaClient(api_key="your-api-key")

try:
    memories = client.list_memories(cluster_ids=["your-cluster-id"])
except NebulaAuthenticationException as e:
    # fail fast: fix credentials/permissions
    raise
except NebulaRateLimitException as e:
    # retry with jittered backoff (see snippet above)
    pass
except NebulaValidationException as e:
    # correct input and reissue
    pass
except NebulaException as e:
    # generic handling (e.status_code, e.message, e.details, e.request_id)
    # For 403 errors, check e.status_code == 403 and adjust permissions
    pass
```

```javascript error_handling.js
const {
  NebulaClient,
  NebulaException,
  NebulaAuthenticationException,
  NebulaRateLimitException,
  NebulaValidationException,
} = require('@nebula-ai/sdk');

const client = new NebulaClient({ apiKey: process.env.NEBULA_API_KEY });

async function main() {
  try {
    const res = await client.listMemories({ cluster_ids: ['your-cluster-id'] });
    console.log(res.length);
  } catch (e) {
    if (e instanceof NebulaAuthenticationException) {
      // do not retry
    } else if (e instanceof NebulaRateLimitException) {
      // retry with jitter
    } else if (e instanceof NebulaValidationException) {
      // fix request
    } else if (e instanceof NebulaException) {
      // generic handling
      // For 403 errors, check e.statusCode === 403 and adjust permissions
    } else {
      // unexpected
    }
  }
}

main();
```

```bash curl_example.sh
# Validate API key
curl -s -H "Authorization: ApiKey YOUR_API_KEY" \
  https://api.nebulacloud.app/v1/health

# Optional: check cluster access
curl -s -H "Authorization: ApiKey YOUR_API_KEY" \
  https://api.nebulacloud.app/clusters/YOUR_CLUSTER_ID/files/list
```

</CodeGroup>

## Notes on idempotency and conflicts

- Use idempotency keys for non-idempotent writes to avoid duplicate effects when retrying.
- Resolve 409 conflicts via versioning or by reconciling state before retrying.

## Next steps

- [Authentication](/authentication)
- [API Reference](/api-reference/overview)
