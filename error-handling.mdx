---
title: 'Error Handling'
description: 'Comprehensive guide to error handling in Nebula using NebulaException and best practices'
---

# Error Handling

Nebula provides a robust error handling system built around the `NebulaException` class and its specialized variants. This page covers how to handle errors effectively when working with the Nebula API.

## NebulaException Overview

`NebulaException` is the base exception class in Nebula, designed to provide structured error information including status codes, detailed error messages, and additional context. It's used throughout the Nebula ecosystem to ensure consistent error handling.

### Exception Hierarchy

Nebula provides several specialized exception types that inherit from `NebulaException`:

| Exception Type | Status Code | Description |
|----------------|-------------|-------------|
| `NebulaException` | Variable | Base exception for all Nebula errors |
| `NebulaClientException` | N/A | Client-side errors (network, configuration) |
| `NebulaAuthenticationException` | 401 | Authentication failures |
| `NebulaRateLimitException` | 429 | Rate limiting errors |
| `NebulaValidationException` | 400 | Input validation errors |
| `NebulaClusterNotFoundException` | 404 | Missing cluster references |

## Authentication Errors

The most common errors you'll encounter are related to authentication and authorization:

| Status Code | Error Type | Description |
|-------------|------------|-------------|
| 401 | `NebulaAuthenticationException` | Invalid or missing authentication |
| 403 | `Forbidden` | Valid authentication but insufficient permissions |
| 404 | `Not Found` | API key or cluster not found |

### Example Error Response

```json
{
  "error": "NebulaAuthenticationException",
  "message": "Invalid API key provided",
  "statusCode": 401,
  "details": {
    "error_type": "authentication_error",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

## Handling Errors in Code

Nebula's SDKs provide consistent error handling patterns across all supported languages.

<CodeGroup>

```python error_handling.py
from nebula_client import NebulaClient, NebulaException, NebulaAuthenticationException

client = NebulaClient(api_key="your-api-key")

try:
    memories = client.list_memories(cluster_ids=["your-cluster-id"])
    print(f"Found {len(memories)} memories")
except NebulaAuthenticationException as e:
    print(f"Authentication failed: {e.message}")
    # Handle authentication error (e.g., refresh token, prompt user)
except NebulaRateLimitException as e:
    print(f"Rate limit exceeded. Retry after: {e.details.get('retry_after', 'unknown')}")
    # Implement exponential backoff
except NebulaValidationException as e:
    print(f"Validation error: {e.message}")
    print(f"Details: {e.details}")
    # Handle validation errors (e.g., fix input data)
except NebulaException as e:
    print(f"Nebula API error ({e.status_code}): {e.message}")
    # Handle general API errors
except Exception as e:
    print(f"Unexpected error: {e}")
    # Handle unexpected errors
```

```javascript error_handling.js
const { NebulaClient, NebulaException, NebulaAuthenticationException } = require('@nebula-ai/sdk');

const client = new NebulaClient({
  apiKey: 'your-api-key'
});

async function listMemories() {
  try {
    const memories = await client.listMemories({
      clusterId: 'your-cluster-id'
    });
    console.log(`Found ${memories.length} memories`);
  } catch (error) {
    if (error instanceof NebulaAuthenticationException) {
      console.error('Authentication failed:', error.message);
      // Handle authentication error
    } else if (error instanceof NebulaRateLimitException) {
      console.error('Rate limit exceeded:', error.message);
      // Implement retry with backoff
    } else if (error instanceof NebulaValidationException) {
      console.error('Validation error:', error.message);
      console.error('Details:', error.details);
      // Handle validation errors
    } else if (error instanceof NebulaException) {
      console.error(`Nebula API error (${error.statusCode}):`, error.message);
      // Handle general API errors
    } else {
      console.error('Unexpected error:', error);
      // Handle unexpected errors
    }
  }
}

listMemories();
```

```go error_handling.go
import (
    "fmt"
    "strings"
    nebulaclient "github.com/oronila/nebula-client-go/nebulaclient"
)

func listMemories() {
    client := nebulaclient.NewClient("your-api-key")

    memories, err := client.ListMemories("your-cluster-id", "ROOT")
    if err != nil {
        if strings.Contains(err.Error(), "401") {
            fmt.Println("Authentication failed. Check your API key.")
        } else if strings.Contains(err.Error(), "403") {
            fmt.Println("Insufficient permissions for this operation.")
        } else if strings.Contains(err.Error(), "429") {
            fmt.Println("Rate limit exceeded. Please wait before retrying.")
        } else {
            fmt.Printf("Error: %v\n", err)
        }
    }
}
```

```bash curl_example.sh
# Authentication error example
curl -H "Authorization: ApiKey invalid_key" \
     https://api.nebulacloud.app/clusters/your-cluster-id/files/list

# Response:
# {
#   "error": "NebulaAuthenticationException",
#   "message": "Invalid API key",
#   "statusCode": 401
# }
```

</CodeGroup>

## Best Practices (Essentials)

- Catch specific exceptions first (`NebulaAuthenticationException`, `NebulaRateLimitException`), then fall back to `NebulaException`.
- Use basic exponential backoff for 429s; do not retry authentication errors.
- Log errors with operation context and status code.

<Tip>Handle authentication (401) and rate limit (429) errors explicitly; never retry 401s, and use exponential backoff for 429s.</Tip>

### Minimal Retry Example (Python)
```python
import time

def with_backoff(fn, retries=3):
    delay = 1
    for attempt in range(retries):
        try:
            return fn()
        except NebulaRateLimitException:
            if attempt == retries - 1:
                raise
            time.sleep(delay)
            delay *= 2
```

## Quick Testing

```bash
# Validate API key
curl -s -H "Authorization: ApiKey YOUR_API_KEY" \
  https://api.nebulacloud.app/v1/health

# Optional: check cluster access
curl -s -H "Authorization: ApiKey YOUR_API_KEY" \
  https://api.nebulacloud.app/clusters/YOUR_CLUSTER_ID/files/list
```

## Next Steps

- [Authentication](/authentication)
- [API Reference](/api-reference/overview)
