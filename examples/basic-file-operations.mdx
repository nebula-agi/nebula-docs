---
title: 'Basic File Operations'
description: 'Practical examples of basic file operations with Nebula API'
---

# Basic File Operations Examples

This guide provides practical examples of common file operations using the Nebula API. These examples demonstrate real-world usage patterns and best practices.

## File Upload Examples

### Upload a Single File

<Tabs>
  <Tab title="Python">
    ```python
    from nebula import NebulaClient
    import os
    
    # Initialize client
    client = NebulaClient(api_key=os.getenv("NEBULA_API_KEY"))
    
    def upload_single_file(cluster_id, file_path):
        """Upload a single file to a cluster"""
        try:
            # Check if file exists
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File not found: {file_path}")
            
            # Upload the file
            result = client.upload_file(
                cluster_id=cluster_id,
                file_path=file_path
            )
            
            print(f"Successfully uploaded: {file_path}")
            print(f"   File ID: {result.file_id}")
            print(f"   File Name: {result.file_name}")
            print(f"   Size: {result.size} bytes")
            
            return result
            
        except Exception as e:
            print(f"Failed to upload {file_path}: {e}")
            raise
    
    # Usage
    result = upload_single_file("your-cluster-id", "document.pdf")
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const { NebulaClient } = require('@oronila/nebula-client');
    const fs = require('fs');
    
    // Initialize client
    const client = new NebulaClient({
      apiKey: process.env.NEBULA_API_KEY
    });
    
    async function uploadSingleFile(clusterId, filePath) {
      try {
        // Check if file exists
        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
        
        // Upload the file
        const result = await client.uploadFile({
          clusterId: clusterId,
          filePath: filePath
        });
        
        console.log(`Successfully uploaded: ${filePath}`);
        console.log(`   File ID: ${result.fileId}`);
        console.log(`   File Name: ${result.fileName}`);
        console.log(`   Size: ${result.size} bytes`);
        
        return result;
        
      } catch (error) {
        console.error(`Failed to upload ${filePath}:`, error);
        throw error;
      }
    }
    
    // Usage
    uploadSingleFile('your-cluster-id', 'document.pdf')
      .then(result => console.log('Upload completed'))
      .catch(error => console.error('Upload failed:', error));
    ```
  </Tab>
  <Tab title="Go">
    ```go
    package main
    
    import (
        "fmt"
        "log"
        "os"
        
        "github.com/oronila/nebula-client-go/nebulaclient"
    )
    
    // Initialize client
    client := nebulaclient.NewClient(os.Getenv("NEBULA_API_KEY"))
    
    func uploadSingleFile(clusterID, filePath string) (*nebulaclient.File, error) {
        // Check if file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) {
            return nil, fmt.Errorf("file not found: %s", filePath)
        }
        
        // Open file
        file, err := os.Open(filePath)
        if err != nil {
            return nil, fmt.Errorf("error opening file: %v", err)
        }
        defer file.Close()
        
        // Upload the file
        result, err := client.UploadFile(clusterID, file, filepath.Base(filePath), "ROOT")
        if err != nil {
            return nil, fmt.Errorf("error uploading file: %v", err)
        }
        
        fmt.Printf("Successfully uploaded: %s\n", filePath)
        fmt.Printf("   File ID: %s\n", result.ID)
        fmt.Printf("   File Name: %s\n", result.Name)
        fmt.Printf("   Size: %d bytes\n", result.Size)
        
        return result, nil
    }
    
    // Usage
    func main() {
        result, err := uploadSingleFile("your-cluster-id", "document.pdf")
        if err != nil {
            log.Fatalf("Upload failed: %v", err)
        }
        fmt.Println("Upload completed successfully")
    }
    ```
  </Tab>
</Tabs>

### Upload Multiple Files with Progress

<Tabs>
  <Tab title="Python">
    ```python
    import os
    from tqdm import tqdm
    
    def upload_multiple_files(cluster_id, file_paths, show_progress=True):
        """Upload multiple files with progress tracking"""
        results = []
        failed_uploads = []
        
        # Create progress bar
        if show_progress:
            pbar = tqdm(file_paths, desc="Uploading files")
        else:
            pbar = file_paths
        
        for file_path in pbar:
            try:
                # Update progress bar description
                if show_progress:
                    pbar.set_description(f"Uploading {os.path.basename(file_path)}")
                
                # Upload file
                result = client.upload_file(
                    cluster_id=cluster_id,
                    file_path=file_path
                )
                
                results.append({
                    'file_path': file_path,
                    'result': result,
                    'status': 'success'
                })
                
            except Exception as e:
                failed_uploads.append({
                    'file_path': file_path,
                    'error': str(e),
                    'status': 'failed'
                })
                
                if show_progress:
                    pbar.set_description(f"Failed: {os.path.basename(file_path)}")
        
        if show_progress:
            pbar.close()
        
        # Print summary
        print(f"\nüìä Upload Summary:")
        print(f"   ‚úÖ Successful: {len(results)}")
        print(f"   ‚ùå Failed: {len(failed_uploads)}")
        
        if failed_uploads:
            print(f"\n‚ùå Failed uploads:")
            for failed in failed_uploads:
                print(f"   - {failed['file_path']}: {failed['error']}")
        
        return results, failed_uploads
    
    # Usage
    file_paths = [
        "document1.pdf",
        "document2.pdf", 
        "image1.jpg",
        "data.csv"
    ]
    
    results, failed = upload_multiple_files("your-cluster-id", file_paths)
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const fs = require('fs');
    const path = require('path');
    
    async function uploadMultipleFiles(clusterId, filePaths, showProgress = true) {
      const results = [];
      const failedUploads = [];
      
      console.log(`üì§ Starting upload of ${filePaths.length} files...`);
      
      for (let i = 0; i < filePaths.length; i++) {
        const filePath = filePaths[i];
        const fileName = path.basename(filePath);
        
        if (showProgress) {
          process.stdout.write(`\rüì§ Uploading ${fileName} (${i + 1}/${filePaths.length})`);
        }
        
        try {
          const result = await client.uploadFile({
            clusterId: clusterId,
            filePath: filePath
          });
          
          results.push({
            filePath: filePath,
            result: result,
            status: 'success'
          });
          
        } catch (error) {
          failedUploads.push({
            filePath: filePath,
            error: error.message,
            status: 'failed'
          });
          
          if (showProgress) {
            process.stdout.write(`\r‚ùå Failed: ${fileName}`);
          }
        }
      }
      
      if (showProgress) {
        console.log('\n'); // New line after progress
      }
      
      // Print summary
      console.log(`üìä Upload Summary:`);
      console.log(`   ‚úÖ Successful: ${results.length}`);
      console.log(`   ‚ùå Failed: ${failedUploads.length}`);
      
      if (failedUploads.length > 0) {
        console.log(`\n‚ùå Failed uploads:`);
        failedUploads.forEach(failed => {
          console.log(`   - ${failed.filePath}: ${failed.error}`);
        });
      }
      
      return { results, failedUploads };
    }
    
    // Usage
    const filePaths = [
      'document1.pdf',
      'document2.pdf',
      'image1.jpg',
      'data.csv'
    ];
    
    uploadMultipleFiles('your-cluster-id', filePaths)
      .then(({ results, failedUploads }) => {
        console.log('Upload process completed');
      })
      .catch(error => {
        console.error('Upload process failed:', error);
      });
    ```
  </Tab>
  <Tab title="Go">
    ```go
    import (
        "fmt"
        "log"
        "path/filepath"
        "sync"
        "time"
    )
    
    func uploadMultipleFiles(clusterID string, filePaths []string, showProgress bool) ([]UploadResult, []UploadError) {
        results := make([]UploadResult, 0)
        failedUploads := make([]UploadError, 0)
        var mu sync.Mutex
        
        fmt.Printf("üì§ Starting upload of %d files...\n", len(filePaths))
        
        var wg sync.WaitGroup
        semaphore := make(chan struct{}, 5) // Limit concurrent uploads
        
        for i, filePath := range filePaths {
            wg.Add(1)
            go func(path string, index int) {
                defer wg.Done()
                semaphore <- struct{}{} // Acquire
                defer func() { <-semaphore }() // Release
                
                fileName := filepath.Base(path)
                
                if showProgress {
                    fmt.Printf("\rüì§ Uploading %s (%d/%d)", fileName, index+1, len(filePaths))
                }
                
                file, err := os.Open(path)
                if err != nil {
                    mu.Lock()
                    failedUploads = append(failedUploads, UploadError{
                        FilePath: path,
                        Error:    err.Error(),
                    })
                    mu.Unlock()
                    return
                }
                defer file.Close()
                
                result, err := client.UploadFile(clusterID, file, fileName, "ROOT")
                if err != nil {
                    mu.Lock()
                    failedUploads = append(failedUploads, UploadError{
                        FilePath: path,
                        Error:    err.Error(),
                    })
                    mu.Unlock()
                    return
                }
                
                mu.Lock()
                results = append(results, UploadResult{
                    FilePath: path,
                    Result:   result,
                })
                mu.Unlock()
            }(filePath, i)
        }
        
        wg.Wait()
        
        if showProgress {
            fmt.Println() // New line after progress
        }
        
        // Print summary
        fmt.Printf("üìä Upload Summary:\n")
        fmt.Printf("   ‚úÖ Successful: %d\n", len(results))
        fmt.Printf("   ‚ùå Failed: %d\n", len(failedUploads))
        
        if len(failedUploads) > 0 {
            fmt.Printf("\n‚ùå Failed uploads:\n")
            for _, failed := range failedUploads {
                fmt.Printf("   - %s: %s\n", failed.FilePath, failed.Error)
            }
        }
        
        return results, failedUploads
    }
    
    type UploadResult struct {
        FilePath string
        Result   *nebulaclient.File
    }
    
    type UploadError struct {
        FilePath string
        Error    string
    }
    
    // Usage
    filePaths := []string{
        "document1.pdf",
        "document2.pdf",
        "image1.jpg",
        "data.csv",
    }
    
    results, failed := uploadMultipleFiles("your-cluster-id", filePaths, true)
    ```
  </Tab>
</Tabs>

## File Download Examples

### Download a Single File

<Tabs>
  <Tab title="Python">
    ```python
    def download_single_file(cluster_id, file_id, output_path):
        """Download a single file from a cluster"""
        try:
            # Download the file
            downloaded_path = client.download_file(
                cluster_id=cluster_id,
                file_id=file_id,
                output_path=output_path
            )
            
            # Get file size
            file_size = os.path.getsize(downloaded_path)
            
            print(f"Successfully downloaded: {downloaded_path}")
            print(f"   File ID: {file_id}")
            print(f"   Size: {file_size} bytes")
            
            return downloaded_path
            
        except Exception as e:
            print(f"Failed to download file {file_id}: {e}")
            raise
    
    # Usage
    downloaded_path = download_single_file(
        "your-cluster-id", 
        "file-uuid", 
        "downloaded_document.pdf"
    )
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    async function downloadSingleFile(clusterId, fileId, outputPath) {
      try {
        // Download the file
        await client.downloadFile({
          clusterId: clusterId,
          fileId: fileId,
          outputPath: outputPath
        });
        
        // Get file size
        const stats = fs.statSync(outputPath);
        
        console.log(`Successfully downloaded: ${outputPath}`);
        console.log(`   File ID: ${fileId}`);
        console.log(`   Size: ${stats.size} bytes`);
        
        return outputPath;
        
      } catch (error) {
        console.error(`Failed to download file ${fileId}:`, error);
        throw error;
      }
    }
    
    // Usage
    downloadSingleFile('your-cluster-id', 'file-uuid', 'downloaded_document.pdf')
      .then(path => console.log('Download completed'))
      .catch(error => console.error('Download failed:', error));
    ```
  </Tab>
  <Tab title="Go">
    ```go
    func downloadSingleFile(clusterID, fileID, outputPath string) (string, error) {
        // Download the file
        err := client.DownloadFile(clusterID, fileID, outputPath)
        if err != nil {
            return "", fmt.Errorf("error downloading file: %v", err)
        }
        
        // Get file size
        info, err := os.Stat(outputPath)
        if err != nil {
            return "", fmt.Errorf("error getting file info: %v", err)
        }
        
        fmt.Printf("Successfully downloaded: %s\n", outputPath)
        fmt.Printf("   File ID: %s\n", fileID)
        fmt.Printf("   Size: %d bytes\n", info.Size())
        
        return outputPath, nil
    }
    
    // Usage
    downloadedPath, err := downloadSingleFile("your-cluster-id", "file-uuid", "downloaded_document.pdf")
    if err != nil {
        log.Fatalf("Download failed: %v", err)
    }
    ```
  </Tab>
</Tabs>

### Download All Files in a Folder

<Tabs>
  <Tab title="Python">
    ```python
    import os
    
    def download_folder_contents(cluster_id, folder_id, output_dir):
        """Download all files in a folder"""
        try:
            # Create output directory if it doesn't exist
            os.makedirs(output_dir, exist_ok=True)
            
            # List files in the folder
            files = client.list_files(
                cluster_id=cluster_id,
                folder_id=folder_id
            )
            
            downloaded_files = []
            failed_downloads = []
            
            print(f"üìÅ Found {len(files)} items in folder")
            
            for file in files:
                if file.type == "file":
                    try:
                        # Create output path
                        output_path = os.path.join(output_dir, file.name)
                        
                        # Download file
                        downloaded_path = client.download_file(
                            cluster_id=cluster_id,
                            file_id=file.id,
                            output_path=output_path
                        )
                        
                        downloaded_files.append({
                            'file_id': file.id,
                            'name': file.name,
                            'path': downloaded_path,
                            'size': file.size
                        })
                        
                        print(f"Successfully downloaded: {file.name}")
                        
                    except Exception as e:
                        failed_downloads.append({
                            'file_id': file.id,
                            'name': file.name,
                            'error': str(e)
                        })
                        print(f"Failed to download: {file.name}")
                else:
                    print(f"üìÅ Skipping folder: {file.name}")
            
            # Print summary
            print(f"\nüìä Download Summary:")
            print(f"   ‚úÖ Downloaded: {len(downloaded_files)}")
            print(f"   ‚ùå Failed: {len(failed_downloads)}")
            
            return downloaded_files, failed_downloads
            
        except Exception as e:
            print(f"Failed to list folder contents: {e}")
            raise
    
    # Usage
    downloaded, failed = download_folder_contents(
        "your-cluster-id",
        "folder-uuid",
        "./downloads"
    )
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const path = require('path');
    
    async function downloadFolderContents(clusterId, folderId, outputDir) {
      try {
        // Create output directory if it doesn't exist
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // List files in the folder
        const files = await client.listFiles({
          clusterId: clusterId,
          folderId: folderId
        });
        
        const downloadedFiles = [];
        const failedDownloads = [];
        
        console.log(`üìÅ Found ${files.length} items in folder`);
        
        for (const file of files) {
          if (file.type === 'file') {
            try {
              // Create output path
              const outputPath = path.join(outputDir, file.name);
              
              // Download file
              await client.downloadFile({
                clusterId: clusterId,
                fileId: file.id,
                outputPath: outputPath
              });
              
              downloadedFiles.push({
                fileId: file.id,
                name: file.name,
                path: outputPath,
                size: file.size
              });
              
              console.log(`Successfully downloaded: ${file.name}`);
              
            } catch (error) {
              failedDownloads.push({
                fileId: file.id,
                name: file.name,
                error: error.message
              });
              console.log(`Failed to download: ${file.name}`);
            }
          } else {
            console.log(`üìÅ Skipping folder: ${file.name}`);
          }
        }
        
        // Print summary
        console.log(`\nüìä Download Summary:`);
        console.log(`   ‚úÖ Downloaded: ${downloadedFiles.length}`);
        console.log(`   ‚ùå Failed: ${failedDownloads.length}`);
        
        return { downloadedFiles, failedDownloads };
        
      } catch (error) {
        console.error(`Failed to list folder contents:`, error);
        throw error;
      }
    }
    
    // Usage
    downloadFolderContents('your-cluster-id', 'folder-uuid', './downloads')
      .then(({ downloadedFiles, failedDownloads }) => {
        console.log('Download process completed');
      })
      .catch(error => {
        console.error('Download process failed:', error);
      });
    ```
  </Tab>
  <Tab title="Go">
    ```go
    func downloadFolderContents(clusterID, folderID, outputDir string) ([]DownloadedFile, []DownloadError) {
        // Create output directory if it doesn't exist
        if err := os.MkdirAll(outputDir, 0755); err != nil {
            log.Fatalf("Error creating output directory: %v", err)
        }
        
        // List files in the folder
        files, err := client.ListFiles(clusterID, folderID)
        if err != nil {
            log.Fatalf("Error listing files: %v", err)
        }
        
        downloadedFiles := make([]DownloadedFile, 0)
        failedDownloads := make([]DownloadError, 0)
        
        fmt.Printf("üìÅ Found %d items in folder\n", len(files))
        
        for _, file := range files {
            if file.Type == "file" {
                // Create output path
                outputPath := filepath.Join(outputDir, file.Name)
                
                // Download file
                err := client.DownloadFile(clusterID, file.ID, outputPath)
                if err != nil {
                    failedDownloads = append(failedDownloads, DownloadError{
                        FileID: file.ID,
                        Name:   file.Name,
                        Error:  err.Error(),
                    })
                    fmt.Printf("Failed to download: %s\n", file.Name)
                    continue
                }
                
                downloadedFiles = append(downloadedFiles, DownloadedFile{
                    FileID: file.ID,
                    Name:   file.Name,
                    Path:   outputPath,
                    Size:   file.Size,
                })
                
                fmt.Printf("Successfully downloaded: %s\n", file.Name)
            } else {
                fmt.Printf("üìÅ Skipping folder: %s\n", file.Name)
            }
        }
        
        // Print summary
        fmt.Printf("\nüìä Download Summary:\n")
        fmt.Printf("   ‚úÖ Downloaded: %d\n", len(downloadedFiles))
        fmt.Printf("   ‚ùå Failed: %d\n", len(failedDownloads))
        
        return downloadedFiles, failedDownloads
    }
    
    type DownloadedFile struct {
        FileID string
        Name   string
        Path   string
        Size   int64
    }
    
    type DownloadError struct {
        FileID string
        Name   string
        Error  string
    }
    
    // Usage
    downloaded, failed := downloadFolderContents("your-cluster-id", "folder-uuid", "./downloads")
    ```
  </Tab>
</Tabs>

## File Organization Examples

### Create Organized Folder Structure

<Tabs>
  <Tab title="Python">
    ```python
    def create_organized_structure(cluster_id):
        """Create an organized folder structure for different file types"""
        
        # Define folder structure
        folders = {
            "documents": {
                "research": "Research Papers",
                "reports": "Reports",
                "presentations": "Presentations"
            },
            "media": {
                "images": "Images",
                "videos": "Videos",
                "audio": "Audio Files"
            },
            "data": {
                "datasets": "Datasets",
                "exports": "Exports",
                "backups": "Backups"
            }
        }
        
        created_folders = {}
        
        # Create main folders
        for main_folder, sub_folders in folders.items():
            try:
                main_folder_obj = client.create_folder(
                    cluster_id=cluster_id,
                    folder_name=main_folder.title()
                )
                created_folders[main_folder] = main_folder_obj.id
                print(f"üìÅ Created main folder: {main_folder.title()}")
                
                # Create sub-folders
                for sub_key, sub_name in sub_folders.items():
                    sub_folder_obj = client.create_folder(
                        cluster_id=cluster_id,
                        folder_name=sub_name,
                        parent_folder_id=main_folder_obj.id
                    )
                    created_folders[f"{main_folder}/{sub_key}"] = sub_folder_obj.id
                    print(f"   üìÅ Created sub-folder: {sub_name}")
                    
            except Exception as e:
                print(f"Failed to create folder {main_folder}: {e}")
        
        return created_folders
    
    # Usage
    folder_structure = create_organized_structure("your-cluster-id")
    print(f"\nüìã Folder structure created: {len(folder_structure)} folders")
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    async function createOrganizedStructure(clusterId) {
      // Define folder structure
      const folders = {
        documents: {
          research: 'Research Papers',
          reports: 'Reports',
          presentations: 'Presentations'
        },
        media: {
          images: 'Images',
          videos: 'Videos',
          audio: 'Audio Files'
        },
        data: {
          datasets: 'Datasets',
          exports: 'Exports',
          backups: 'Backups'
        }
      };
      
      const createdFolders = {};
      
      // Create main folders
      for (const [mainFolder, subFolders] of Object.entries(folders)) {
        try {
          const mainFolderObj = await client.createFolder({
            clusterId: clusterId,
            folderName: mainFolder.charAt(0).toUpperCase() + mainFolder.slice(1)
          });
          
          createdFolders[mainFolder] = mainFolderObj.id;
          console.log(`üìÅ Created main folder: ${mainFolder.charAt(0).toUpperCase() + mainFolder.slice(1)}`);
          
          // Create sub-folders
          for (const [subKey, subName] of Object.entries(subFolders)) {
            const subFolderObj = await client.createFolder({
              clusterId: clusterId,
              folderName: subName,
              parentFolderId: mainFolderObj.id
            });
            
            createdFolders[`${mainFolder}/${subKey}`] = subFolderObj.id;
            console.log(`   üìÅ Created sub-folder: ${subName}`);
          }
          
        } catch (error) {
          console.error(`Failed to create folder ${mainFolder}:`, error);
        }
      }
      
      return createdFolders;
    }
    
    // Usage
    createOrganizedStructure('your-cluster-id')
      .then(folderStructure => {
        console.log(`\nüìã Folder structure created: ${Object.keys(folderStructure).length} folders`);
      })
      .catch(error => {
        console.error('Failed to create folder structure:', error);
      });
    ```
  </Tab>
  <Tab title="Go">
    ```go
    func createOrganizedStructure(clusterID string) map[string]string {
        // Define folder structure
        folders := map[string]map[string]string{
            "documents": {
                "research":      "Research Papers",
                "reports":       "Reports",
                "presentations": "Presentations",
            },
            "media": {
                "images": "Images",
                "videos": "Videos",
                "audio":  "Audio Files",
            },
            "data": {
                "datasets": "Datasets",
                "exports":  "Exports",
                "backups":  "Backups",
            },
        }
        
        createdFolders := make(map[string]string)
        
        // Create main folders
        for mainFolder, subFolders := range folders {
            mainFolderName := strings.Title(mainFolder)
            
            mainFolderObj, err := client.CreateFolder(clusterID, mainFolderName, "ROOT")
            if err != nil {
                log.Printf("Failed to create folder %s: %v", mainFolder, err)
                continue
            }
            
            createdFolders[mainFolder] = mainFolderObj.ID
            fmt.Printf("üìÅ Created main folder: %s\n", mainFolderName)
            
            // Create sub-folders
            for subKey, subName := range subFolders {
                subFolderObj, err := client.CreateFolder(clusterID, subName, mainFolderObj.ID)
                if err != nil {
                    log.Printf("Failed to create sub-folder %s: %v", subName, err)
                    continue
                }
                
                createdFolders[fmt.Sprintf("%s/%s", mainFolder, subKey)] = subFolderObj.ID
                fmt.Printf("   üìÅ Created sub-folder: %s\n", subName)
            }
        }
        
        return createdFolders
    }
    
    // Usage
    folderStructure := createOrganizedStructure("your-cluster-id")
    fmt.Printf("\nüìã Folder structure created: %d folders\n", len(folderStructure))
    ```
  </Tab>
</Tabs>

### Organize Files by Type

<Tabs>
  <Tab title="Python">
    ```python
    import os
    from pathlib import Path
    
    def organize_files_by_type(cluster_id, folder_id):
        """Organize files in a folder by their type"""
        
        # Define file type mappings
        file_types = {
            # Documents
            '.pdf': 'documents/reports',
            '.doc': 'documents/reports',
            '.docx': 'documents/reports',
            '.txt': 'documents/reports',
            '.md': 'documents/reports',
            
            # Images
            '.jpg': 'media/images',
            '.jpeg': 'media/images',
            '.png': 'media/images',
            '.gif': 'media/images',
            '.svg': 'media/images',
            
            # Videos
            '.mp4': 'media/videos',
            '.avi': 'media/videos',
            '.mov': 'media/videos',
            '.mkv': 'media/videos',
            
            # Data
            '.csv': 'data/datasets',
            '.json': 'data/datasets',
            '.xlsx': 'data/datasets',
            '.zip': 'data/backups',
            '.tar': 'data/backups',
            '.gz': 'data/backups'
        }
        
        # Get all files in the folder
        files = client.list_files(cluster_id=cluster_id, folder_id=folder_id)
        
        organized_count = 0
        failed_moves = []
        
        for file in files:
            if file.type == "file":
                # Get file extension
                file_ext = Path(file.name).suffix.lower()
                
                if file_ext in file_types:
                    target_folder = file_types[file_ext]
                    
                    try:
                        # Find or create target folder
                        target_folder_id = find_or_create_folder_path(
                            client, cluster_id, target_folder
                        )
                        
                        # Move file to target folder
                        client.move_files(
                            cluster_id=cluster_id,
                            file_ids=[file.id],
                            target_folder_id=target_folder_id
                        )
                        
                        print(f"üìÅ Moved {file.name} to {target_folder}")
                        organized_count += 1
                        
                    except Exception as e:
                        failed_moves.append({
                            'file_name': file.name,
                            'target_folder': target_folder,
                            'error': str(e)
                        })
                        print(f"Failed to move {file.name}: {e}")
                else:
                    print(f"Unknown file type: {file.name}")
        
        # Print summary
        print(f"\nüìä Organization Summary:")
        print(f"   ‚úÖ Organized: {organized_count}")
        print(f"   ‚ùå Failed: {len(failed_moves)}")
        
        return organized_count, failed_moves
    
    def find_or_create_folder_path(client, cluster_id, folder_path):
        """Find or create a folder path"""
        parts = folder_path.split('/')
        current_folder_id = "ROOT"
        
        for part in parts:
            # Try to find existing folder
            try:
                folders = client.list_files(
                    cluster_id=cluster_id,
                    folder_id=current_folder_id
                )
                
                # Look for folder with this name
                for folder in folders:
                    if folder.type == "folder" and folder.name.lower() == part.lower():
                        current_folder_id = folder.id
                        break
                else:
                    # Create new folder
                    new_folder = client.create_folder(
                        cluster_id=cluster_id,
                        folder_name=part,
                        parent_folder_id=current_folder_id
                    )
                    current_folder_id = new_folder.id
                    
            except Exception as e:
                print(f"Error creating folder {part}: {e}")
                raise
        
        return current_folder_id
    
    # Usage
    organized, failed = organize_files_by_type("your-cluster-id", "folder-uuid")
    ```
  </Tab>
  <Tab title="Node.js">
    ```javascript
    const path = require('path');
    
    async function organizeFilesByType(clusterId, folderId) {
      // Define file type mappings
      const fileTypes = {
        // Documents
        '.pdf': 'documents/reports',
        '.doc': 'documents/reports',
        '.docx': 'documents/reports',
        '.txt': 'documents/reports',
        '.md': 'documents/reports',
        
        // Images
        '.jpg': 'media/images',
        '.jpeg': 'media/images',
        '.png': 'media/images',
        '.gif': 'media/images',
        '.svg': 'media/images',
        
        // Videos
        '.mp4': 'media/videos',
        '.avi': 'media/videos',
        '.mov': 'media/videos',
        '.mkv': 'media/videos',
        
        // Data
        '.csv': 'data/datasets',
        '.json': 'data/datasets',
        '.xlsx': 'data/datasets',
        '.zip': 'data/backups',
        '.tar': 'data/backups',
        '.gz': 'data/backups'
      };
      
      // Get all files in the folder
      const files = await client.listFiles({
        clusterId: clusterId,
        folderId: folderId
      });
      
      let organizedCount = 0;
      const failedMoves = [];
      
      for (const file of files) {
        if (file.type === 'file') {
          // Get file extension
          const fileExt = path.extname(file.name).toLowerCase();
          
          if (fileExt in fileTypes) {
            const targetFolder = fileTypes[fileExt];
            
            try {
              // Find or create target folder
              const targetFolderId = await findOrCreateFolderPath(
                client, clusterId, targetFolder
              );
              
              // Move file to target folder
              await client.moveFiles({
                clusterId: clusterId,
                fileIds: [file.id],
                targetFolderId: targetFolderId
              });
              
              console.log(`üìÅ Moved ${file.name} to ${targetFolder}`);
              organizedCount++;
              
            } catch (error) {
              failedMoves.push({
                fileName: file.name,
                targetFolder: targetFolder,
                error: error.message
              });
              console.log(`Failed to move ${file.name}: ${error.message}`);
            }
          } else {
            console.log(`Unknown file type: ${file.name}`);
          }
        }
      }
      
      // Print summary
      console.log(`\nüìä Organization Summary:`);
      console.log(`   ‚úÖ Organized: ${organizedCount}`);
      console.log(`   ‚ùå Failed: ${failedMoves.length}`);
      
      return { organizedCount, failedMoves };
    }
    
    async function findOrCreateFolderPath(client, clusterId, folderPath) {
      const parts = folderPath.split('/');
      let currentFolderId = 'ROOT';
      
      for (const part of parts) {
        try {
          // Try to find existing folder
          const folders = await client.listFiles({
            clusterId: clusterId,
            folderId: currentFolderId
          });
          
          // Look for folder with this name
          let found = false;
          for (const folder of folders) {
            if (folder.type === 'folder' && folder.name.toLowerCase() === part.toLowerCase()) {
              currentFolderId = folder.id;
              found = true;
              break;
            }
          }
          
          if (!found) {
            // Create new folder
            const newFolder = await client.createFolder({
              clusterId: clusterId,
              folderName: part,
              parentFolderId: currentFolderId
            });
            currentFolderId = newFolder.id;
          }
          
        } catch (error) {
          console.error(`Error creating folder ${part}:`, error);
          throw error;
        }
      }
      
      return currentFolderId;
    }
    
    // Usage
    organizeFilesByType('your-cluster-id', 'folder-uuid')
      .then(({ organizedCount, failedMoves }) => {
        console.log('Organization completed');
      })
      .catch(error => {
        console.error('Organization failed:', error);
      });
    ```
  </Tab>
  <Tab title="Go">
    ```go
    func organizeFilesByType(clusterID, folderID string) (int, []MoveError) {
        // Define file type mappings
        fileTypes := map[string]string{
            // Documents
            ".pdf":  "documents/reports",
            ".doc":  "documents/reports",
            ".docx": "documents/reports",
            ".txt":  "documents/reports",
            ".md":   "documents/reports",
            
            // Images
            ".jpg":  "media/images",
            ".jpeg": "media/images",
            ".png":  "media/images",
            ".gif":  "media/images",
            ".svg":  "media/images",
            
            // Videos
            ".mp4":  "media/videos",
            ".avi":  "media/videos",
            ".mov":  "media/videos",
            ".mkv":  "media/videos",
            
            // Data
            ".csv":  "data/datasets",
            ".json": "data/datasets",
            ".xlsx": "data/datasets",
            ".zip":  "data/backups",
            ".tar":  "data/backups",
            ".gz":   "data/backups",
        }
        
        // Get all files in the folder
        files, err := client.ListFiles(clusterID, folderID)
        if err != nil {
            log.Fatalf("Error listing files: %v", err)
        }
        
        organizedCount := 0
        failedMoves := make([]MoveError, 0)
        
        for _, file := range files {
            if file.Type == "file" {
                // Get file extension
                fileExt := strings.ToLower(filepath.Ext(file.Name))
                
                if targetFolder, exists := fileTypes[fileExt]; exists {
                    // Find or create target folder
                    targetFolderID, err := findOrCreateFolderPath(client, clusterID, targetFolder)
                    if err != nil {
                        log.Printf("Error creating folder path %s: %v", targetFolder, err)
                        continue
                    }
                    
                    // Move file to target folder
                    err = client.MoveFiles(clusterID, []string{file.ID}, targetFolderID)
                    if err != nil {
                        failedMoves = append(failedMoves, MoveError{
                            FileName:     file.Name,
                            TargetFolder: targetFolder,
                            Error:        err.Error(),
                        })
                        fmt.Printf("Failed to move %s: %v\n", file.Name, err)
                        continue
                    }
                    
                    fmt.Printf("üìÅ Moved %s to %s\n", file.Name, targetFolder)
                    organizedCount++
                } else {
                    fmt.Printf("Unknown file type: %s\n", file.Name)
                }
            }
        }
        
        // Print summary
        fmt.Printf("\nüìä Organization Summary:\n")
        fmt.Printf("   ‚úÖ Organized: %d\n", organizedCount)
        fmt.Printf("   ‚ùå Failed: %d\n", len(failedMoves))
        
        return organizedCount, failedMoves
    }
    
    func findOrCreateFolderPath(client *nebulaclient.Client, clusterID, folderPath string) (string, error) {
        parts := strings.Split(folderPath, "/")
        currentFolderID := "ROOT"
        
        for _, part := range parts {
            // Try to find existing folder
            folders, err := client.ListFiles(clusterID, currentFolderID)
            if err != nil {
                return "", fmt.Errorf("error listing folders: %v", err)
            }
            
            // Look for folder with this name
            found := false
            for _, folder := range folders {
                if folder.Type == "folder" && strings.ToLower(folder.Name) == strings.ToLower(part) {
                    currentFolderID = folder.ID
                    found = true
                    break
                }
            }
            
            if !found {
                // Create new folder
                newFolder, err := client.CreateFolder(clusterID, part, currentFolderID)
                if err != nil {
                    return "", fmt.Errorf("error creating folder %s: %v", part, err)
                }
                currentFolderID = newFolder.ID
            }
        }
        
        return currentFolderID, nil
    }
    
    type MoveError struct {
        FileName     string
        TargetFolder string
        Error        string
    }
    
    // Usage
    organizedCount, failedMoves := organizeFilesByType("your-cluster-id", "folder-uuid")
    ```
  </Tab>
</Tabs>

## Next Steps

- [Advanced File Management](/examples/advanced-file-management) - More complex file operations
- [Collection Workflows](/examples/collection-workflows) - Working with collections
- [Error Handling](/guides/error-handling) - Comprehensive error handling patterns
- [API Reference](/api-reference/files) - Complete file operation API reference 