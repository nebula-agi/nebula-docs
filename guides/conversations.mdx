---
title: 'Conversations Guide'
description: 'Learn how to create and manage conversational AI interactions in Nebula'
---

# Conversations Guide

Create and manage conversational AI interactions with context-aware chat experiences using Nebula's memory system.

## How Conversations Work

Conversations are stored as **conversation memories** - containers that hold entire conversations with all their messages. Each conversation gets its own memory ID, and you add messages to that container using `store_memory()`:

- **`role`**: Speaker identifier (`user`, `assistant`, etc.)
- **`memory_id`**: The conversation container to add messages to
- **`content`**: The message text (can be single message or multiple messages)

<Info>A conversation memory contains the complete chat history. Use `memory_id` to add messages to the same conversation container. See [Core Concepts](/guides/concepts) to understand how memories work.</Info>

## Creating Conversations

<CodeGroup>

```python Python
from nebula_client import NebulaClient

client = NebulaClient(api_key="your-api-key")

# Create conversation with initial message
conversation_memory_id = client.store_memory({
    "collection_id": "chat-collection",
    "content": "Hello! How can I help you today?",
    "role": "assistant",
    "metadata": {
        "conversation_name": "Support Chat",
        "topic": "customer_support"
    }
})
# This creates a conversation container
```

```javascript JavaScript
const { NebulaClient } = require('@nebula-ai/sdk');

const client = new NebulaClient({ apiKey: 'your-api-key' });

// Create conversation with initial message
const conversationId = await client.storeMemory({
  collection_id: "chat-collection",
  content: "Hello! How can I help you today?",
  role: "assistant",
  metadata: {
    conversation_name: "Support Chat",
    topic: "customer_support"
  }
});
// This creates a conversation container
```

</CodeGroup>

## Adding Messages

Add more messages to the conversation container:

<CodeGroup>

```python Python
# Add single message to conversation
client.store_memory({
    "memory_id": conversation_memory_id,  # Same conversation container
    "collection_id": "chat-collection",
    "content": "I need help with my account",
    "role": "user"
})

# Add multiple messages to same conversation
client.store_memory({
    "memory_id": conversation_memory_id,  # Same container
    "collection_id": "chat-collection",
    "content": [
        {
            "content": "What specific issue are you having?",
            "role": "assistant"
        },
        {
            "content": "I can't log in to my account",
            "role": "user"
        }
    ]
})
# The conversation now contains all 4 messages
```

```javascript JavaScript
// Add single message to conversation
await client.storeMemory({
  memory_id: conversationId,  // Same conversation container
  collection_id: "chat-collection",
  content: "I need help with my account",
  role: "user"
});

// Add multiple messages to same conversation
await client.storeMemory({
  memory_id: conversationId,  // Same container
  collection_id: "chat-collection",
  content: [
    {
      content: "What specific issue are you having?",
      role: "assistant"
    },
    {
      content: "I can't log in to my account",
      role: "user"
    }
  ]
});
// The conversation now contains all 4 messages
```

</CodeGroup>


## Retrieving Messages

<CodeGroup>

```python Python
# Get entire conversation (all messages)
messages = client.get_conversation_messages(conversation_memory_id)

for message in messages:
    role = message.metadata.get('source_role', 'unknown')
    print(f"[{role.upper()}]: {message.content}")
```

```javascript JavaScript
// Get entire conversation (all messages)
const messages = await client.getConversationMessages(conversationId);

messages.forEach(message => {
  const role = message.metadata.source_role || 'unknown';
  console.log(`[${role.toUpperCase()}]: ${message.content}`);
});

// Get multiple conversations (batch)
const conversationIds = ["conv_1", "conv_2", "conv_3"];
const batchResults = await client.getConversationMessages(conversationIds);

for (const [conversationId, messages] of Object.entries(batchResults)) {
  console.log(`Conversation ${conversationId}: ${messages.length} messages`);
}
```

</CodeGroup>

## Listing Conversations

<CodeGroup>

```python Python
# List conversations
conversations = client.list_conversations(limit=50, offset=0)

for conv in conversations:
    name = conv.get("name", "Unnamed Conversation")
    print(f"{name} - ID: {conv.get('id')}")

# Filter by collection
filtered_conversations = client.list_conversations(
    collection_ids=["chat-collection"]
)
```

```javascript JavaScript  
// List conversations
const conversations = await client.listConversations({
  limit: 50,
  offset: 0
});

conversations.forEach(conv => {
  const name = conv.name || "Unnamed Conversation";
  console.log(`${name} - ID: ${conv.id}`);
});

// Filter by collection
const filtered = await client.listConversations({
  collection_ids: ["chat-collection"]
});
```

</CodeGroup>

## Best Practices

- **Use descriptive metadata**: Add `conversation_name` and topic information
- **Link messages properly**: Always use `memory_id` to maintain conversation flow  
- **Organize by collections**: Group conversations by purpose or project
- **Consider message limits**: Keep conversations at reasonable sizes for performance

## Next Steps

- [Core Concepts](/guides/concepts) - Understanding memories and chunks
- [Memory Operations Guide](/guides/memory-operations) - Store and search memories
- [Collections Guide](/guides/collections) - Organize memories effectively
- [Advanced Features](/guides/advanced-features) - Chunk-level authority and optimization