---
title: 'Search Guide'
description: 'Semantic search and intelligent filtering in Nebula'
---

# Search Guide

Nebula provides powerful hybrid search that combines semantic (vector) and full-text search for optimal results.

## Basic Search

<CodeGroup>

```python Python
from nebula import Nebula

nebula = Nebula(api_key="your-api-key")

# Simple search
results = nebula.search(
    query="machine learning algorithms",
    collection_ids=["research-collection"]
)

for result in results:
    print(f"Score: {result.score:.3f}")
    print(f"Content: {result.content}")
    print(f"Metadata: {result.metadata}\n")
```

```javascript JavaScript
const { Nebula } = require('@nebula-ai/sdk');
const nebula = new Nebula({ apiKey: 'your-api-key' });

const results = await nebula.search({
  query: "machine learning algorithms",
  collection_ids: ["research-collection"]
});

results.forEach(result => {
  console.log(`Score: ${result.score.toFixed(3)}`);
  console.log(`Content: ${result.content}`);
  console.log(`Metadata: ${JSON.stringify(result.metadata)}\n`);
});
```

```bash cURL
curl -X POST "https://api.nebulacloud.app/v1/memories/search" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "query": "machine learning algorithms",
    "collection_ids": ["research-collection"]
  }'
```

</CodeGroup>

**Search results include:**
- `score`: Relevance score (0-1, higher is better)
- `content`: The memory content
- `metadata`: Custom metadata
- `memory_id`: Memory ID for retrieval
- `collection_id`: Which collection it belongs to
- `created_at`: Timestamp

## Search with Metadata Filters

Combine semantic search with metadata filtering:

<CodeGroup>

```python Python
# Search with filters
results = nebula.search(
    query="project updates",
    collection_ids=["work-collection"],
    filters={
        "priority": "high",
        "status": "active",
        "team": "engineering"
    },
    effort="medium"
)
```

```javascript JavaScript
// Search with filters
const results = await nebula.search({
  query: "project updates",
  collection_ids: ["work-collection"],
  filters: {
    priority: "high",
    status: "active",
    team: "engineering"
  },
  effort: "medium"
});
```

```bash cURL
curl -X POST "https://api.nebulacloud.app/v1/memories/search" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "query": "project updates",
    "collection_ids": ["work-collection"],
    "filters": {
      "metadata.priority": {"$eq": "high"},
      "metadata.status": {"$eq": "active"},
      "metadata.team": {"$eq": "engineering"}
    },
    "effort": "medium"
  }'
```

</CodeGroup>

See [Metadata Filtering](/guides/metadata-filtering) for advanced filter operators.

## Hybrid Search Weights

Control the balance between semantic and full-text search:

<CodeGroup>

```python Python
results = nebula.search(
    query="neural networks",
    collection_ids=["research-collection"],
    search_settings={
        "semantic_weight": 0.7,    # Semantic search weight
        "fulltext_weight": 0.3  # Keyword search weight
    }
)
```

```javascript JavaScript
const results = await nebula.search({
  query: "neural networks",
  collection_ids: ["research-collection"],
  searchSettings: {
    semanticWeight: 0.7,    // Semantic search weight
    fulltextWeight: 0.3  // Keyword search weight
  }
});
```

```bash cURL
curl -X POST "https://api.nebulacloud.app/v1/memories/search" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "query": "neural networks",
    "collection_ids": ["research-collection"],
    "search_settings": {
      "semantic_weight": 0.7,
      "fulltext_weight": 0.3
    }
  }'
```

</CodeGroup>

**Weight Guidelines:**
- `semantic_weight: 0.8, fulltext_weight: 0.2` - Prefer semantic meaning (default)
- `semantic_weight: 0.5, fulltext_weight: 0.5` - Balanced
- `semantic_weight: 0.2, fulltext_weight: 0.8` - Prefer exact keyword matches

<Tip>Default weights (0.8 semantic, 0.2 fulltext) work well for most use cases. Adjust only if needed.</Tip>

## Search Effort

Nebula always performs hybrid search. By default, effort is set to `auto` which adapts based on query complexity. You can optionally control the computational budget using `effort` (auto/low/medium/high) - this controls traversal compute and exploration depth, not the exact number of results. Adjust the balance between semantic and keyword search using `semantic_weight` and `fulltext_weight`.

## Advanced Search Options

### Search Multiple Collections

<CodeGroup>

```python Python
# Search across multiple collections
results = nebula.search(
    query="customer feedback",
    collection_ids=["support-2024", "support-2023", "surveys"],
    effort="medium"
)
```

```javascript JavaScript
// Search across multiple collections
const results = await nebula.search({
  query: "customer feedback",
  collection_ids: ["support-2024", "support-2023", "surveys"],
  effort: "medium"
});
```

```bash cURL
curl -X POST "https://api.nebulacloud.app/v1/memories/search" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "query": "customer feedback",
    "collection_ids": ["support-2024", "support-2023", "surveys"],
    "effort": "medium"
  }'
```

</CodeGroup>

### Search All Collections

Omit `collection_ids` to search across all accessible collections:

<CodeGroup>

```python Python
# Search everything
results = nebula.search(
    query="product roadmap",
    effort="high"
)
```

```javascript JavaScript
// Search everything
const results = await nebula.search({
  query: "product roadmap",
  effort: "high"
});
```

```bash cURL
curl -X POST "https://api.nebulacloud.app/v1/memories/search" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{
    "query": "product roadmap",
    "effort": "high"
  }'
```

</CodeGroup>

<Warning>Searching all collections is slower than targeting specific collections.</Warning>

### Complex Metadata Filters

```python
# Advanced filtering with multiple operators
results = nebula.search(
    query="bug reports",
    collection_ids=["issues-collection"],
    filters={
        "severity": {"$in": ["critical", "high"]},
        "status": {"$ne": "closed"},
        "created_date": {"$gte": "2024-01-01"}
    }
)
```

**Available operators:** `$eq`, `$ne`, `$in`, `$nin`, `$gt`, `$gte`, `$lt`, `$lte`, `$like`, `$ilike`, `$overlap`, `$contains`, `$and`, `$or`

Full details in [Metadata Filtering](/guides/metadata-filtering).

## Authority Scores

Control which content should be prioritized in search results using authority scores (0-1).

```python
# High authority for verified content
nebula.store_memory({
    "collection_id": "docs",
    "content": "Official API documentation...",
    "authority": 0.95,
    "metadata": {"verified": True}
})

# Lower authority for user-contributed content
nebula.store_memory({
    "collection_id": "docs",
    "content": "I think you do it this way...",
    "authority": 0.4,
    "metadata": {"verified": False}
})
```

| Score | Use Case |
|-------|----------|
| `0.9-1.0` | Verified facts, official docs |
| `0.7-0.9` | Reliable sources, quality content |
| `0.5-0.7` | General content (default) |
| `0.3-0.5` | Uncertain information |
| `0.0-0.3` | Low-quality or spam |

You can also set authority per message in conversations to prioritize specific chunks:

```python
conv_id = nebula.store_memory({
    "collection_id": "support",
    "content": "Here is the verified answer...",
    "role": "assistant",
    "authority": 0.9
})

nebula.store_memory({
    "memory_id": conv_id,
    "collection_id": "support",
    "content": "I'm not sure, maybe try this?",
    "role": "user",
    "authority": 0.4
})
```

<Tip>Default authority is 0.5. Higher authority content ranks higher in search results.</Tip>


## Search Best Practices

1. **Use natural language queries** - "How do I reset my password?" works better than "password reset"
2. **Target specific collections** - Faster and more relevant results
3. **Start with defaults** - Only adjust weights if results aren't good
4. **Leverage metadata filters** - Narrow results by structured fields
5. **Choose appropriate effort** - Balance between coverage and performance (auto/low/medium/high)
6. **Cache frequent queries** - Store common search results

## Next Steps

- [Metadata Filtering](/guides/metadata-filtering) - Advanced filter operators
- [Memory Operations](/guides/memory-operations) - Store and manage memories
