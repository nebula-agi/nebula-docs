---
title: 'Go Client'
description: 'Official Go client library for the Nebula Memory API'
---

# Go Client

The official Go client library for the Nebula Memory API provides a simple and high-performance interface for storing, retrieving, and searching memories with advanced clustering capabilities.

## Table of Contents

1. [Installation & Setup](#installation--setup)
2. [Client Initialization](#client-initialization)
3. [Cluster Management](#cluster-management)
4. [Memory Storage](#memory-storage)
5. [Memory Retrieval](#memory-retrieval)
6. [Search Operations](#search-operations)
7. [Memory Management](#memory-management)
8. [Error Handling](#error-handling)
9. [Data Models](#data-models)
10. [Examples](#examples)

## Installation & Setup

### Prerequisites

- Go 1.20+
- Nebula Cloud API key

### Installation

```bash
go get github.com/oronila/nebula-client-go
```

### Environment Setup

```bash
export NEBULA_API_KEY="your_api_key_here"
```

## Client Initialization

### Basic Initialization

```go
import (
    "github.com/oronila/nebula-client-go/nebulaclient"
)

// Using environment variable
client := nebulaclient.NewClient(os.Getenv("NEBULA_API_KEY"))

// Or with explicit API key
client := nebulaclient.NewClient("your_api_key_here")
```

### Advanced Configuration

```go
client := nebulaclient.NewClient(
    "your_api_key_here",
    nebulaclient.WithBaseURL("https://api.nebulacloud.app"), // Default
    nebulaclient.WithTimeout(30*time.Second), // Default timeout
)
```

### Context Usage

```go
ctx := context.Background()
client := nebulaclient.NewClient("your_api_key")
// Your operations here
memory, err := client.Store(ctx, &nebulaclient.StoreRequest{
    Content:   "Hello world",
    ClusterID: "cluster_123",
})
```

## Cluster Management

Clusters help organize memories and provide access control.

### Create Cluster

```go
cluster, err := client.CreateCluster(ctx, &nebulaclient.CreateClusterRequest{
    Name:        "research_notes",
    Description: "Cluster for research-related memories",
    Metadata:    map[string]interface{}{ "category": "academic", "priority": "high" },
})
```

**Parameters:**
- `Name` (string): Cluster name (required)
- `Description` (string, optional): Cluster description
- `Metadata` (map[string]interface{}, optional): Additional metadata

**Returns:** `*Cluster` with cluster details

### Get Cluster

```go
cluster, err := client.GetCluster(ctx, "cluster_id_here")
```

**Parameters:**
- `clusterID` (string): ID of the cluster to retrieve

**Returns:** `*Cluster`

### List Clusters

```go
clusters, err := client.ListClusters(ctx, &nebulaclient.ListClustersRequest{
    Limit:  100, // Default: 100
    Offset: 0,   // Default: 0
})
```

**Parameters:**
- `Limit` (int): Maximum number of clusters to return (1-1000)
- `Offset` (int): Number of clusters to skip

**Returns:** `[]*Cluster`

### Update Cluster

```go
updatedCluster, err := client.UpdateCluster(ctx, &nebulaclient.UpdateClusterRequest{
    ClusterID:   "cluster_id_here",
    Name:        "new_name", // Optional
    Description: "new_description", // Optional
    Metadata:    map[string]interface{}{ "updated": true }, // Optional
})
```

**Parameters:**
- `ClusterID` (string): ID of the cluster to update
- `Name` (string, optional): New name
- `Description` (string, optional): New description
- `Metadata` (map[string]interface{}, optional): New metadata

**Returns:** Updated `*Cluster`

**Note:** Update operations may fail if the new name conflicts with existing clusters.

### Delete Cluster

```go
success, err := client.DeleteCluster(ctx, "cluster_id_here")
```

**Parameters:**
- `clusterID` (string): ID of the cluster to delete

**Returns:** `bool` if successful

## Memory Storage

### Store Individual Memory

```go
memory, err := client.Store(ctx, &nebulaclient.StoreRequest{
    Content: "User prefers email communication over phone calls",
    ClusterID: "user_preferences", // Required
    Metadata: map[string]interface{}{
        "user_id":         "user_123",
        "preference_type": "communication",
        "importance":      "high",
    },
})
```

**Parameters:**
- `Content` (string): The memory content to store (required)
- `ClusterID` (string): Cluster to store the memory in (required)
- `Metadata` (map[string]interface{}, optional): Additional metadata

**Returns:** `*Memory`

## Memory Retrieval

### Get Specific Memory

```go
memory, err := client.Get(ctx, "memory_id_here")
```

**Parameters:**
- `memoryID` (string): ID of the memory to retrieve (required)

**Returns:** `*Memory` with content retrieved from chunks

### List Memories

```go
memories, err := client.ListMemories(ctx, &nebulaclient.ListMemoriesRequest{
    ClusterID: "cluster_123", // Required
    Limit:     100,      // Default: 100
    Offset:    0,        // Default: 0
})
```

**Parameters:**
- `ClusterID` (string): Cluster ID to list memories from (required)
- `Limit` (int): Maximum number of memories to return
- `Offset` (int): Number of memories to skip

**Returns:** `[]*Memory` with content retrieved from chunks

### Get Cluster Memories

```go
memories, err := client.GetClusterMemories(ctx, &nebulaclient.GetClusterMemoriesRequest{
    ClusterID: "cluster_id_here",
    Limit:     100,    // Default: 100
    Offset:    0,      // Default: 0
})
```

**Parameters:**
- `ClusterID` (string): ID of the cluster (required)
- `Limit` (int): Maximum number of memories to return
- `Offset` (int): Number of memories to skip

**Returns:** `[]*Memory`

## Search Operations

### General Search

```go
results, err := client.Search(ctx, &nebulaclient.SearchRequest{
    Query:         "artificial intelligence",
    ClusterID:     "research_cluster",                // Required
    Limit:         10,                                 // Default: 10
    RetrievalType: "simple",                          // Default: "simple"
    Filters:       map[string]interface{}{ "metadata.topic": "ai" }, // Optional
})
```

**Parameters:**
- `Query` (string): Search query (required)
- `ClusterID` (string): Cluster to search within (required)
- `Limit` (int): Maximum number of results to return
- `RetrievalType` (string): Type of retrieval ("simple", "reasoning", "planning")
- `Filters` (map[string]interface{}, optional): Search filters

**Returns:** `[]*SearchResult`

### Search Types

The SDK supports different retrieval types:

- **`simple`**: Basic semantic search
- **`reasoning`**: Enhanced reasoning-based search
- **`planning`**: Planning-oriented search

## Memory Management

### Delete Memory

```go
success, err := client.Delete(ctx, "memory_id_here")
```

**Parameters:**
- `memoryID` (string): ID of the memory to delete (required)

**Returns:** `bool` if successful

## Error Handling

### Error Types

The SDK returns errors as Go `error` values, with custom error types for specific cases:

- `NebulaException`              // Base exception
- `NebulaClientException`        // Client-side errors
- `NebulaAuthenticationException` // Authentication errors
- `NebulaRateLimitException`     // Rate limiting errors
- `NebulaValidationException`    // Validation errors

### Error Handling Example

```go
memory, err := client.Store(ctx, &nebulaclient.StoreRequest{
    Content:   "Test memory",
    ClusterID: "test_cluster",
})
if err != nil {
    switch err.(type) {
    case *nebulaclient.NebulaAuthenticationException:
        fmt.Println("Invalid API key")
    case *nebulaclient.NebulaRateLimitException:
        fmt.Println("Rate limit exceeded")
    case *nebulaclient.NebulaValidationException:
        fmt.Printf("Validation error: %v\n", err)
    case *nebulaclient.NebulaException:
        fmt.Printf("API error: %v\n", err)
    default:
        fmt.Printf("Unexpected error: %v\n", err)
    }
}
```

## Data Models

### Memory Object

```go
type Memory struct {
    ID         string                 // Memory/document ID
    Content    string                 // Memory content (retrieved from chunks)
    Metadata   map[string]interface{} // Additional metadata
    ClusterIDs []string               // Associated clusters
    CreatedAt  string                 // Creation timestamp
    UpdatedAt  string                 // Last update timestamp
}
```

### Cluster Object

```go
type Cluster struct {
    ID           string                 // Cluster ID
    Name         string                 // Cluster name
    Description  string                 // Cluster description
    Metadata     map[string]interface{} // Additional metadata
    UserCount    int                    // Number of users
    DocumentCount int                   // Number of documents
    CreatedAt    string                 // Creation timestamp
    UpdatedAt    string                 // Last update timestamp
}
```

### SearchResult Object

```go
type SearchResult struct {
    ID         string                 // Result ID
    Content    string                 // Result content
    Score      float64                // Relevance score (0.0-1.0)
    Metadata   map[string]interface{} // Additional metadata
    DocumentID string                 // Source document ID
}
```

## Examples

### Complete Workflow Example

```go
package main

import (
    "context"
    "fmt"
    "os"
    "github.com/oronila/nebula-client-go/nebulaclient"
)

func main() {
    ctx := context.Background()
    client := nebulaclient.NewClient(os.Getenv("NEBULA_API_KEY"))

    // Create a cluster
    cluster, _ := client.CreateCluster(ctx, &nebulaclient.CreateClusterRequest{
        Name:        "customer_support",
        Description: "Customer support interactions",
    })

    // Store customer preferences
    memory, _ := client.Store(ctx, &nebulaclient.StoreRequest{
        Content: "Customer prefers email communication over phone calls",
        Metadata: map[string]interface{}{
            "user_id":         "user_123",
            "preference_type": "communication",
        },
        ClusterID: cluster.ID,
    })

    // Retrieve the stored memory
    retrievedMemory, _ := client.Get(ctx, memory.ID)
    fmt.Printf("Retrieved content: %s\n", retrievedMemory.Content)
    fmt.Printf("Cluster IDs: %v\n", retrievedMemory.ClusterIDs)

    // List memories from the cluster
    clusterMemories, _ := client.ListMemories(ctx, &nebulaclient.ListMemoriesRequest{ClusterID: cluster.ID})
    for _, memory := range clusterMemories {
        fmt.Printf("Memory: %.100s...\n", memory.Content)
    }

    // Search within the cluster
    results, _ := client.Search(ctx, &nebulaclient.SearchRequest{
        Query:     "communication preferences",
        ClusterID: cluster.ID,
        Limit:     5,
    })
    for _, result := range results {
        fmt.Printf("Score: %.3f\n", result.Score)
        fmt.Printf("Content: %s\n", result.Content)
        fmt.Println("---")
    }

    // Clean up
    client.Delete(ctx, memory.ID)
    client.DeleteCluster(ctx, cluster.ID)
}
```

### Cluster Management Example

```go
// Create multiple clusters
researchCluster, _ := client.CreateCluster(ctx, &nebulaclient.CreateClusterRequest{
    Name:        "Research Notes",
    Description: "Academic research materials",
})
supportCluster, _ := client.CreateCluster(ctx, &nebulaclient.CreateClusterRequest{
    Name:        "Customer Support",
    Description: "Customer support interactions",
})

// Store memories in different clusters
client.Store(ctx, &nebulaclient.StoreRequest{
    Content:   "Machine learning algorithms overview",
    ClusterID: researchCluster.ID,
    Metadata:  map[string]interface{}{ "topic": "ai", "type": "overview" },
})
client.Store(ctx, &nebulaclient.StoreRequest{
    Content:   "Customer login issue resolved",
    ClusterID: supportCluster.ID,
    Metadata:  map[string]interface{}{ "issue_type": "login", "status": "resolved" },
})

// List all clusters
clusters, _ := client.ListClusters(ctx, &nebulaclient.ListClustersRequest{})
for _, cluster := range clusters {
    fmt.Printf("Cluster: %s\n", cluster.Name)
    fmt.Printf("ID: %s\n", cluster.ID)
    fmt.Printf("Documents: %d\n", cluster.DocumentCount)
    fmt.Println("---")
}

// Get memories from specific cluster
memories, _ := client.GetClusterMemories(ctx, &nebulaclient.GetClusterMemoriesRequest{
    ClusterID: researchCluster.ID,
    Limit:     50,
})
for _, memory := range memories {
    fmt.Printf("Memory: %.100s...\n", memory.Content)
    fmt.Printf("Cluster IDs: %v\n", memory.ClusterIDs)
    fmt.Println("---")
}
```

### Search and Filter Example

```go
// Search with filters
results, _ := client.Search(ctx, &nebulaclient.SearchRequest{
    Query:     "machine learning",
    ClusterID: "research_cluster_id",
    Limit:     5,
    Filters: map[string]interface{}{
        "metadata.topic":     "ai",
        "metadata.importance": "high",
    },
})
for _, result := range results {
    fmt.Printf("Score: %.3f\n", result.Score)
    fmt.Printf("Content: %s\n", result.Content)
    fmt.Printf("Document ID: %s\n", result.DocumentID)
    fmt.Println("---")
}

// Search within a specific cluster
clusterResults, _ := client.Search(ctx, &nebulaclient.SearchRequest{
    Query:         "login issues",
    ClusterID:     "support_cluster_id",
    RetrievalType: "reasoning",
})
for _, result := range clusterResults {
    fmt.Printf("Cluster Result: %s\n", result.Content)
}
```

### Memory Management Example

```go
// Store multiple memories
var memories []*nebulaclient.Memory
for i := 0; i < 3; i++ {
    memory, _ := client.Store(ctx, &nebulaclient.StoreRequest{
        Content:   fmt.Sprintf("Test memory %d about Go programming", i+1),
        ClusterID: "test_cluster_id",
        Metadata:  map[string]interface{}{ "test": true, "index": i },
    })
    memories = append(memories, memory)
}

// List memories from specific cluster
clusterMemories, _ := client.ListMemories(ctx, &nebulaclient.ListMemoriesRequest{
    ClusterID: "test_cluster_id",
    Limit:     50,
})
fmt.Printf("Cluster memories: %d\n", len(clusterMemories))

// Get specific memory
if len(memories) > 0 {
    specificMemory, _ := client.Get(ctx, memories[0].ID)
    fmt.Printf("Retrieved memory: %s\n", specificMemory.Content)
    fmt.Printf("Cluster IDs: %v\n", specificMemory.ClusterIDs)
}

// Delete memories
for _, memory := range memories {
    client.Delete(ctx, memory.ID)
    fmt.Printf("Deleted memory: %s\n", memory.ID)
}
```

## Best Practices

1. **Use Clusters**: Organize memories into clusters for better management
2. **Rich Metadata**: Include relevant metadata for better search and filtering
3. **Content Retrieval**: The SDK automatically retrieves content from chunks
4. **Error Handling**: Always implement proper error handling
5. **Rate Limiting**: Be mindful of API rate limits
6. **Deterministic IDs**: The SDK automatically handles deduplication
7. **Cluster Filtering**: Use cluster filtering for targeted searches

## API Limits

- **Clusters**: Varies by plan
- **Documents**: Varies by plan
- **Chunks**: Varies by plan
- **Rate Limits**: Varies by plan
- **Request Timeout**: 30 seconds (configurable)

For specific limits, check your Nebula Cloud plan details.

## Version History

### Version 0.0.18 (Current)
- Fixed `ListMemories` to retrieve content from chunks
- Fixed `Get` method to handle `results` wrapper
- Fixed cluster filtering in all methods
- Improved content retrieval from document chunks
- All core functionality working correctly

### Version 0.0.17
- Fixed `Get` method to retrieve content from chunks
- Fixed `UpdateCluster` to use POST method
- Fixed `GetCluster` to handle `results` wrapper

### Version 0.0.14
- Unified `Retrieve` into `Search` method
- Removed `agent_id` concept
- Updated to use cluster terminology
- Fixed cluster filtering with `$overlap` operator

## Next Steps

- [Quick Start Guide](/quickstart) - Get up and running quickly
- [API Reference](/api-reference/overview) - Explore all available endpoints
- [Examples](/examples/basic-file-operations) - See practical usage examples
- [Error Handling](/guides/error-handling) - Learn about error handling patterns 