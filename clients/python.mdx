---
title: 'Python Client'
description: 'Official Python client library for the Nebula Memory API'
---

# Python Client

The official Python client library for the Nebula Memory API provides a simple and intuitive interface for storing, retrieving, and searching memories with advanced clustering capabilities.

## Table of Contents

1. [Installation & Setup](#installation--setup)
2. [Client Initialization](#client-initialization)
3. [Cluster Management](#cluster-management)
4. [Memory Storage](#memory-storage)
5. [Memory Retrieval](#memory-retrieval)
6. [Search Operations](#search-operations)
7. [Memory Management](#memory-management)
8. [Error Handling](#error-handling)
9. [Data Models](#data-models)
10. [Examples](#examples)

## Installation & Setup

### Prerequisites

- Python 3.8+
- Nebula API key

### Installation

```bash
pip install nebula-client
```

**Current Version**: 0.0.21

### Environment Setup

```bash
export NEBULA_API_KEY="your_api_key_here"
```

## Client Initialization

### Basic Initialization

```python
from nebula_client import NebulaClient

# Using environment variable
client = NebulaClient()

# Or with explicit API key
client = NebulaClient(api_key="your_api_key_here")
```

### Advanced Configuration

```python
client = NebulaClient(
    api_key="your_api_key_here",
    base_url="https://api.nebulacloud.app",  # Default
    timeout=30.0  # Default timeout in seconds
)
```

### Context Manager Usage

```python
with NebulaClient(api_key="your_api_key") as client:
    # Your operations here
    memory = client.store(content="Hello world", cluster_id="cluster_123")
```

## Cluster Management

Clusters help organize memories and provide access control.

### Create Cluster

```python
cluster = client.create_cluster(
    name="research_notes",
    description="Cluster for research-related memories",
    metadata={"category": "academic", "priority": "high"}
)
```

**Parameters:**
- `name` (str): Cluster name (required)
- `description` (str, optional): Cluster description
- `metadata` (dict, optional): Additional metadata

**Returns:** `Cluster` object with cluster details

### Get Cluster

```python
cluster = client.get_cluster("cluster_id_here")
```

**Parameters:**
- `cluster_id` (str): ID of the cluster to retrieve

**Returns:** `Cluster` object

### List Clusters

```python
clusters = client.list_clusters(
    limit=100,  # Default: 100
    offset=0    # Default: 0
)
```

**Parameters:**
- `limit` (int): Maximum number of clusters to return (1-1000)
- `offset` (int): Number of clusters to skip

**Returns:** List of `Cluster` objects

### Update Cluster

```python
updated_cluster = client.update_cluster(
    cluster_id="cluster_id_here",
    name="new_name",  # Optional
    description="new_description",  # Optional
    metadata={"updated": True}  # Optional
)
```

**Parameters:**
- `cluster_id` (str): ID of the cluster to update
- `name` (str, optional): New name
- `description` (str, optional): New description
- `metadata` (dict, optional): New metadata

**Returns:** Updated `Cluster` object

**Note:** Update operations may fail if the new name conflicts with existing clusters.

### Delete Cluster

```python
success = client.delete_cluster("cluster_id_here")
```

**Parameters:**
- `cluster_id` (str): ID of the cluster to delete

**Returns:** `True` if successful

## Memory Storage

### Store Individual Memory

#### Option 1: Using Memory Class (Structured)
```python
from nebula_client import Memory

memory = Memory(
    cluster_id="user_preferences",  # Required
    content="User prefers email communication over phone calls",
    metadata={
        "user_id": "user_123",
        "preference_type": "communication",
        "importance": "high"
    }
)
memory_id = client.store_memory(memory)
```

#### Option 2: Using Plain Dict (Simple)
```python
memory_data = {
    "cluster_id": "user_preferences",
    "content": "User prefers email communication over phone calls",
    "metadata": {
        "user_id": "user_123",
        "preference_type": "communication",
        "importance": "high"
    }
}
memory_id = client.store_memory(memory_data)
```

**Parameters:**
- `memory`: Either a `Memory` object or dict with the following keys:
  - `cluster_id` (str): Cluster to store the memory in (required)
  - `content` (str): The memory content to store (required)
  - `role` (str, optional): For conversation messages ('user', 'assistant', etc.)
  - `parent_id` (str, optional): Parent conversation ID
  - `metadata` (dict, optional): Additional metadata

**Returns:** Document ID as string

## Memory Retrieval

### Get Specific Memory

```python
memory = client.get_memory("memory_id_here")
```

**Parameters:**
- `memory_id` (str): ID of the memory to retrieve (required)

**Returns:** `Memory` object with content retrieved from chunks

### List Memories

```python
memories = client.list_memories(
    cluster_id="cluster_123",  # Required
    limit=100,      # Default: 100
    offset=0        # Default: 0
)
```

**Parameters:**
- `cluster_id` (str): Cluster ID to list memories from (required)
- `limit` (int): Maximum number of memories to return
- `offset` (int): Number of memories to skip

**Returns:** List of `Memory` objects with content retrieved from chunks

### Get Cluster Memories

```python
memories = client.get_cluster_memories(
    cluster_id="cluster_id_here",
    limit=100,    # Default: 100
    offset=0      # Default: 0
)
```

**Parameters:**
- `cluster_id` (str): ID of the cluster (required)
- `limit` (int): Maximum number of memories to return
- `offset` (int): Number of memories to skip

**Returns:** List of `Memory` objects

## Search Operations

### General Search

```python
results = client.search(
    query="artificial intelligence",
    cluster_id="research_cluster",               # Required
    limit=10,                                    # Default: 10
    retrieval_type="simple",                     # Default: "simple"
    filters={"metadata.topic": "ai"}             # Optional
)
```

**Parameters:**
- `query` (str): Search query (required)
- `cluster_id` (str): Cluster to search within (required)
- `limit` (int): Maximum number of results to return
- `retrieval_type` (str): Type of retrieval ("simple", "reasoning", "planning")
- `filters` (dict, optional): Search filters

**Returns:** List of `SearchResult` objects

### Search Types

The SDK supports different retrieval types:

- **`simple`**: Basic semantic search
- **`reasoning`**: Enhanced reasoning-based search
- **`planning`**: Planning-oriented search

## Memory Management

### Delete Memory

```python
success = client.delete("memory_id_here")
```

**Parameters:**
- `memory_id` (str): ID of the memory to delete (required)

**Returns:** `True` if successful

## Error Handling

### Exception Types

```python
from nebula_client.exceptions import (
    NebulaException,              # Base exception
    NebulaClientException,        # Client-side errors
    NebulaAuthenticationException, # Authentication errors
    NebulaRateLimitException,     # Rate limiting errors
    NebulaValidationException     # Validation errors
)
```

### Error Handling Example

```python
try:
    memory = client.store(
        content="Test memory",
        cluster_id="test_cluster"
    )
except NebulaAuthenticationException:
    print("Invalid API key")
except NebulaRateLimitException:
    print("Rate limit exceeded")
except NebulaValidationException as e:
    print(f"Validation error: {e}")
except NebulaException as e:
    print(f"API error: {e}")
except Exception as e:
    print(f"Unexpected error: {e}")
```

## Data Models

### Memory Object

```python
class Memory:
    id: str                    # Memory/document ID
    content: str              # Memory content (retrieved from chunks)
    metadata: dict            # Additional metadata
    cluster_ids: List[str]    # Associated clusters
    created_at: str           # Creation timestamp
    updated_at: str           # Last update timestamp
```

### Cluster Object

```python
class Cluster:
    id: str                   # Cluster ID
    name: str                 # Cluster name
    description: str          # Cluster description
    metadata: dict            # Additional metadata
    user_count: int           # Number of users
    document_count: int       # Number of documents
    created_at: str           # Creation timestamp
    updated_at: str           # Last update timestamp
```

### SearchResult Object

```python
class SearchResult:
    id: str                   # Result ID
    content: str              # Result content
    score: float              # Relevance score (0.0-1.0)
    metadata: dict            # Additional metadata
    document_id: str          # Source document ID
```

## Examples

### Complete Workflow Example

```python
from nebula_client import NebulaClient

# Initialize client
client = NebulaClient(api_key="your_api_key")

# Create a cluster
cluster = client.create_cluster(
    name="customer_support",
    description="Customer support interactions"
)

    # Store customer preferences
    memory_data = {
        "cluster_id": cluster.id,
        "content": "Customer prefers email communication over phone calls",
        "metadata": {
            "user_id": "user_123",
            "preference_type": "communication"
        }
    }
    memory_id = client.store_memory(memory_data)

# Retrieve the stored memory
retrieved_memory = client.get_memory(memory_id)
print(f"Retrieved content: {retrieved_memory.content}")
print(f"Cluster IDs: {retrieved_memory.cluster_ids}")

# List memories from the cluster
cluster_memories = client.list_memories(cluster_ids=[cluster.id])
for memory in cluster_memories:
    print(f"Memory: {memory.content[:100]}...")

# Search within the cluster
results = client.search(
    query="communication preferences",
    cluster_ids=[cluster.id],
    limit=5
)

for result in results:
    print(f"Score: {result.score:.3f}")
    print(f"Content: {result.content}")
    print("---")

# Clean up
client.delete(memory_id)
client.delete_cluster(cluster.id)
```

### Cluster Management Example

```python
# Create multiple clusters
research_cluster = client.create_cluster(
    name="Research Notes",
    description="Academic research materials"
)

support_cluster = client.create_cluster(
    name="Customer Support",
    description="Customer support interactions"
)

# Store memories in different clusters
memory_data = {
    "cluster_id": research_cluster.id,
    "content": "Machine learning algorithms overview",
    "metadata": {"topic": "ai", "type": "overview"}
}
client.store_memory(memory_data)

memory_data2 = {
    "cluster_id": support_cluster.id,
    "content": "Customer login issue resolved",
    "metadata": {"issue_type": "login", "status": "resolved"}
}
client.store_memory(memory_data2)

# List all clusters
clusters = client.list_clusters()
for cluster in clusters:
    print(f"Cluster: {cluster.name}")
    print(f"ID: {cluster.id}")
    print(f"Documents: {cluster.document_count}")
    print("---")

# Get memories from specific cluster
memories = client.list_memories(
    cluster_ids=[research_cluster.id],
    limit=50
)

for memory in memories:
    print(f"Memory: {memory.content[:100]}...")
    print(f"Cluster IDs: {memory.cluster_ids}")
    print("---")
```

### Search and Filter Example

```python
# Search with filters
results = client.search(
    query="machine learning",
    cluster_ids=["research_cluster_id"],
    limit=5,
    filters={
        "metadata.topic": "ai",
        "metadata.importance": "high"
    }
)

for result in results:
    print(f"Score: {result.score:.3f}")
    print(f"Content: {result.content}")
    print(f"Document ID: {result.document_id}")
    print("---")

# Search within a specific cluster
cluster_results = client.search(
    query="login issues",
    cluster_ids=["support_cluster_id"],
    retrieval_type="reasoning"
)

for result in cluster_results:
    print(f"Cluster Result: {result.content}")
```

### Memory Management Example

```python
# Store multiple memories
memories = []
for i in range(3):
    memory_data = {
        "cluster_id": "test_cluster_id",
        "content": f"Test memory {i+1} about Python programming",
        "metadata": {"test": True, "index": i}
    }
    memory_id = client.store_memory(memory_data)
    memories.append({"id": memory_id, "content": memory_data["content"]})

# List memories from specific cluster
cluster_memories = client.list_memories(
    cluster_ids=["test_cluster_id"],
    limit=50
)
print(f"Cluster memories: {len(cluster_memories)}")

# Get specific memory
if memories:
    specific_memory = client.get_memory(memories[0]["id"])
    print(f"Retrieved memory: {specific_memory.content}")
    print(f"Cluster IDs: {specific_memory.cluster_ids}")

# Delete memories
for memory in memories:
    client.delete(memory["id"])
    print(f"Deleted memory: {memory['id']}")
```

## Best Practices

1. **Use Clusters**: Organize memories into clusters for better management
2. **Rich Metadata**: Include relevant metadata for better search and filtering
3. **Content Retrieval**: The SDK automatically retrieves content from chunks
4. **Error Handling**: Always implement proper error handling
5. **Rate Limiting**: Be mindful of API rate limits
6. **Deterministic IDs**: The SDK automatically handles deduplication
7. **Cluster Filtering**: Use cluster filtering for targeted searches

## API Limits

- **Clusters**: Varies by plan
- **Documents**: Varies by plan
- **Chunks**: Varies by plan
- **Rate Limits**: Varies by plan
- **Request Timeout**: 30 seconds (configurable)

For specific limits, check your Nebula plan details.

## Version History

### Version 0.0.18 (Current)
- Fixed `list_memories` to retrieve content from chunks
- Fixed `get` method to handle `results` wrapper
- Fixed cluster filtering in all methods
- Improved content retrieval from document chunks
- All core functionality working correctly

### Version 0.0.17
- Fixed `get` method to retrieve content from chunks
- Fixed `update_cluster` to use POST method
- Fixed `get_cluster` to handle `results` wrapper

### Version 0.0.14
- Unified `retrieve` into `search` method
- Removed `agent_id` concept
- Updated to use cluster terminology
- Fixed cluster filtering with `$overlap` operator

## Next Steps

- [Quick Start Guide](/quickstart) - Get up and running quickly
- [API Reference](/api-reference/overview) - Explore all available endpoints
- [Memory Operations](/guides/memory-operations) - See practical usage examples
- [Error Handling](/guides/error-handling) - Learn about error handling patterns 